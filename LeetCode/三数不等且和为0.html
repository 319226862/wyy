<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const nums = [0,0,0,0]
        // let arr = []
        // const map = new Map()
            // 三重循环？
            // for (let i = 0; i < nums.length; i++) {
            //     for (let j = 0; j < nums.length; j++) {
            //         for (let k = 0; k < nums.length; k++) {
            //             if (nums[i]!=nums[j]&&nums[j]!=nums[k]&&nums[i]!=nums[k]&&(nums[i]+nums[j]+nums[k]=='0')){
            //                 console.log(i,j,k);
            //                 console.log(nums[i],nums[j],nums[k]);
            //                 map.set([nums[i],nums[j],nums[k]],i)
            //             }
            //         }
            //     }
            // }
            // 数组内部一样，但是排序方式不一样，怎么去重？？？
            // console.log(map);

            
            // console.log(newNum);
            // 利用hashmap
            
            // for (let i = 0; i < newNum.length; i++) {
            //     for (let j = i + 1; j < newNum.length; j++) {
                    // 如果0减去两数之和，得出的结果已经存在hashmap中
                    // 我们遍历得到的第三个数+之前存在map中的两数之和=0
                    // if (map.has(0-(newNum[i]+newNum[j]))&&i!=j&&i!=map.get(0-(newNum[i]+newNum[j]))&&j!=map.get(0-(newNum[i]+newNum[j]))){
                    //     // i，j就是两数之和的那两个数的索引号
                    //     // map.get(0-(new[i]+new[j]))就是第三个数
                    //     // console.log(i,j,map.get(0-(newNum[i]+newNum[j])));
                    //     arr.push(newNum[i],newNum[j],newNum[map.get(0-(newNum[i]+newNum[j]))])
                    //     // console.log(newNum[i],newNum[j],newNum[map.get(0-(newNum[i]+newNum[j]))]);
                    //     // return [newNum[i],newNum[j],newNum[map.get(0-(newNum[i]+newNum[j]))]]
                    //     return arr
                    // }
                    // // 如果不存在这个结果，继续将两数之和存入待用
                    // map.set(newNum[i]+newNum[j], i)


                    // again
                    // console.log(newNum[i]+newNum[j]);
                    // if (map.has(newNum[i]+newNum[j])) {
                    //     // console.log(newNum[i],newNum[j]);
                    //     if (newNum[i]!=newNum[j]&&map.has()) {
                            
                    //     }
                    // }
                    // map.set(newNum[i]+newNum[j],i)

                    // 排序+去重数组元素，不用考虑会重复吗？

                // }
            // }
            
            // 排序+去重 ×
            // for (let i = 0; i < newNum.length; i++) {
            //     // console.log(newNum[i]);
            //     if (newNum[i]==newNum[i+1]) {
            //         newNum.splice(i,1)
            //     }
            // }

            // let map = new Map()

            // for (let i = 0; i < newNum.length; i++) {
            //     // if (newNum[i]+newNum[i+1]+newNum[i+2]==0) {
            //     //     console.log(newNum[i],newNum[i+1],newNum[i+2]);
            //     // }
            //     for (let j = i; j < newNum.length; j++) {
            //         for (let k = j; k < newNum.length; k++) {
            //             if (newNum[i]+newNum[j]+newNum[k]==0&&newNum[i]!=newNum[j]&&newNum[j]!=newNum[k]&&newNum[i]!=newNum[k]) {
            //                 console.log(newNum[i],newNum[j],newNum[k]);
            //             }
            //         }
            //     }
            // }

    var threeSum = function(nums) {

            let newNum = nums.sort(function(a,b){
                return a-b
            })

            let arr = []

            if (newNum.every((a)=>{return a==0})==true) {
                arr.push([0,0,0])
                return arr
            }
            else{
                console.log(false);
                for (let i = 0; i < newNum.length - 2; i++) {
                    // 第一个数为n1
                    let n1 = newNum[i]
                    // 如果第一个数就大于0，不用算，没有
                    if (n1 > 0) break;
                    // 跳过重复的数值
                    if (n1 == newNum[i-1] && i-1>0) continue;
                    // 设置左右指针
                    let left = i + 1
                    let right = newNum.length - 1

                    while(left < right){
                        let n2 = newNum[left], n3 = newNum[right]
                        if (n1+n2+n3 === 0) {
                            arr.push([n1,n2,n3])
                            left++;
                            right--;
                        } else if (n1 + n2 + n3 < 0) { // 三数和小于0，则左指针右移
                            left++;
                        } else {      // 三数和大于0，则右指针左移
                            right--;
                        }
                    }
                }
                console.log(arr);
                return arr
            }
            return []
    };


    threeSum(nums)


    </script>
</body>
</html>